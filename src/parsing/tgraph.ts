import type { RuntimeConfig } from "../config";
import { parseHtml, type HtmlNode, type HtmlElement } from "./html_dom";
import { emojify, isEmoticon, resolveRelativeLink, isAbsoluteHttpLink } from "./utils";
import { constructWeservUrl } from "./medium";

type TelegraphNode = string | { tag: string; attrs?: Record<string, string>; children?: Array<TelegraphNode> };

const escapeRegex = (value: string): string => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

const TELEGRAPH_ALLOWED_TAGS = new Set([
  "a", "aside", "b", "blockquote", "br", "code", "em", "figcaption", "figure",
  "h3", "h4", "hr", "i", "iframe", "img", "li", "ol", "p", "pre", "s",
  "strong", "u", "ul", "video"
]);

const TELEGRAPH_REPLACE_TAGS: Record<string, string> = {
  strong: "b",
  em: "i",
  strike: "s",
  del: "s",
  ins: "u",
  big: "b",
  h1: "h3",
  h2: "h4",
  h3: "b",
  h4: "u",
  h5: "p",
  h6: "p",
  details: "blockquote"
};

const TELEGRAPH_TAGS_INSERT_BR_AFTER = new Set(["div", "section", "tr"]);
const TELEGRAPH_DEL_TAGS = new Set(["table", "svg", "script", "noscript", "style", "head", "source"]);
const TELEGRAPH_DISALLOWED_TAGS_IN_LI = new Set(["p", "section"]);
const TELEGRAPH_TAGS_ALLOW_ATTR: Record<string, string> = {
  a: "href",
  img: "src",
  iframe: "src",
  video: "src"
};

const DOMAIN_PATTERN_TEMPLATE = (domains: Array<string>): RegExp =>
  new RegExp(`^https?://(?:[^./]+\\.)?(?:${domains.map(escapeRegex).join("|")})\\.?(?:/|:|$)`, "i");

const BLOCKED_BY_WESERV_DOMAIN = new Set(["sinaimg.cn", "wp.com"]);
const BLOCKED_BY_WESERV_RE = DOMAIN_PATTERN_TEMPLATE(Array.from(BLOCKED_BY_WESERV_DOMAIN));

const buildAllowRefererRe = (config: RuntimeConfig): RegExp => {
  const domains = new Set<string>();
  domains.add("wp.com");
  const relayHost = config.imgRelayServer.replace(/^https?:\/\//, "").replace(/\/.*$/, "").replace(/^\.+|\.+$/g, "");
  const weservHost = config.imagesWeserv.replace(/^https?:\/\//, "").replace(/\/.*$/, "").replace(/^\.+|\.+$/g, "");
  if (relayHost) domains.add(relayHost);
  if (weservHost) domains.add(weservHost);
  return DOMAIN_PATTERN_TEMPLATE(Array.from(domains));
};

export const telegraphIfy = async (
  config: RuntimeConfig,
  html: string,
  opts: { title?: string; link?: string; feedTitle?: string; author?: string; feedLink?: string }
): Promise<string | null> => {
  if (!config.telegraphToken) return null;
  const sanitized = sanitizeTelegraphHtml(config, emojify(html), opts.feedLink);
  const author = opts.feedTitle
    ? `${opts.feedTitle}${opts.author && !opts.feedTitle.includes(opts.author) ? ` (${opts.author})` : ""}`
    : "Generated by RSStT";
  const authorUrl = opts.feedTitle ? opts.link || "" : "https://github.com/Rongronggg9/RSS-to-Telegram-Bot";
  const title = opts.title || "Generated by RSStT";
  const footer =
    `<p>Generated by <a href="https://github.com/Rongronggg9/RSS-to-Telegram-Bot">RSStT</a>. The copyright belongs to the original author.</p>` +
    (opts.link ? `<p><a href="${opts.link}">Source</a></p>` : "");
  const fullHtml = sanitized + footer;
  const content = htmlToTelegraphNodes(fullHtml);
  const response = await fetch("https://api.telegra.ph/createPage", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      access_token: config.telegraphToken,
      title: title.length > 61 ? `${title.slice(0, 60)}\u2026` : title,
      content,
      author_name: author.slice(0, 128),
      author_url: authorUrl.slice(0, 512),
      return_content: false
    })
  });
  const data = (await response.json()) as { ok: boolean; result?: { url: string } };
  if (!data.ok || !data.result?.url) return null;
  return data.result.url;
};

const sanitizeTelegraphHtml = (config: RuntimeConfig, html: string, feedLink?: string): string => {
  const allowRefererRe = buildAllowRefererRe(config);
  const nodes = convertChildren(parseHtml(html), { config, feedLink, allowRefererRe });
  return nodesToHtml(nodes);
};

const htmlToTelegraphNodes = (html: string): Array<TelegraphNode> => {
  const nodes = convertChildren(parseHtml(html), { config: null, feedLink: undefined, allowRefererRe: null });
  return nodes;
};

const convertChildren = (
  children: Array<HtmlNode>,
  ctx: { config: RuntimeConfig | null; feedLink?: string; allowRefererRe: RegExp | null; parentTag?: string }
): Array<TelegraphNode> => {
  const result: Array<TelegraphNode> = [];
  for (const child of children) {
    result.push(...convertNode(child, ctx));
  }
  return result;
};

const convertNode = (
  node: HtmlNode,
  ctx: { config: RuntimeConfig | null; feedLink?: string; allowRefererRe: RegExp | null; parentTag?: string }
): Array<TelegraphNode> => {
  if (node.type === "text") {
    const text = (node as any).data || "";
    return text ? [text] : [];
  }
  if (node.type !== "tag") return [];
  const element = node as HtmlElement;
  const tagName = element.name?.toLowerCase() || "";

  if (ctx.parentTag === "li" && TELEGRAPH_DISALLOWED_TAGS_IN_LI.has(tagName)) {
    return convertChildren(element.children as Array<HtmlNode>, { ...ctx, parentTag: tagName });
  }

  if (tagName === "q") {
    const cite = element.attribs?.cite;
    const inner = convertChildren(element.children as Array<HtmlNode>, { ...ctx, parentTag: tagName });
    if (cite) {
      return [
        "\u201c",
        { tag: "a", attrs: { href: resolveRelativeLink(ctx.feedLink, cite) }, children: inner },
        "\u201d"
      ];
    }
    return ["\u201c", ...inner, "\u201d"];
  }

  if (TELEGRAPH_DEL_TAGS.has(tagName)) {
    if (tagName === "table") {
      return convertTable(element, ctx);
    }
    return [];
  }

  const replacedTag = TELEGRAPH_REPLACE_TAGS[tagName];
  let effectiveTag = replacedTag || tagName;
  const children = convertChildren(element.children as Array<HtmlNode>, { ...ctx, parentTag: tagName });

  if (!TELEGRAPH_ALLOWED_TAGS.has(effectiveTag)) {
    return children;
  }

  if (effectiveTag === "a") {
    const text = childrenToText(children).trim();
    if (!text) return children;
  }

  if (effectiveTag === "img" && isEmoticon(element)) {
    const alt = element.attribs?.alt;
    return alt ? [alt] : [];
  }

  const attrName = TELEGRAPH_TAGS_ALLOW_ATTR[effectiveTag];
  let attrs: Record<string, string> | undefined;
  if (attrName) {
    const rawAttr = element.attribs?.[attrName];
    if (!rawAttr) {
      return children;
    }
    let attrValue = resolveRelativeLink(ctx.feedLink, rawAttr);
    if (!isAbsoluteHttpLink(attrValue)) {
      return children;
    }
    if (ctx.config && ctx.allowRefererRe && !ctx.allowRefererRe.test(attrValue)) {
      if (effectiveTag === "video") {
        attrValue = ctx.config.imgRelayServer + attrValue;
      } else if (effectiveTag === "img") {
        attrValue = BLOCKED_BY_WESERV_RE.test(attrValue)
          ? ctx.config.imgRelayServer + attrValue
          : constructWeservUrl(ctx.config.imagesWeserv, attrValue);
      }
    }
    attrs = { [attrName]: attrValue };
  }

  const nodeObj: TelegraphNode = { tag: effectiveTag, attrs, children: children.length ? children : undefined };
  const output: Array<TelegraphNode> = [nodeObj];
  if (TELEGRAPH_TAGS_INSERT_BR_AFTER.has(tagName)) {
    output.push({ tag: "br" });
  }
  if (replacedTag && tagName.startsWith("h") && !effectiveTag.startsWith("h") && effectiveTag !== "p") {
    output.unshift({ tag: "br" });
    output.push({ tag: "br" });
  }
  return output;
};

const convertTable = (
  element: HtmlElement,
  ctx: { config: RuntimeConfig | null; feedLink?: string; allowRefererRe: RegExp | null }
): Array<TelegraphNode> => {
  const rows = element.children.filter((n) => (n as HtmlElement).type === "tag" && (n as HtmlElement).name === "tr") as Array<HtmlElement>;
  if (!rows.length) return [];
  const contents: Array<TelegraphNode> = [];
  for (let i = 0; i < rows.length; i += 1) {
    const columns = rows[i].children.filter((n) => (n as HtmlElement).type === "tag" && ((n as HtmlElement).name === "td" || (n as HtmlElement).name === "th")) as Array<HtmlElement>;
    if (rows.length > 1 && columns.length > 1) {
      return [];
    }
    for (let j = 0; j < columns.length; j += 1) {
      contents.push(...convertChildren(columns[j].children as Array<HtmlNode>, { ...ctx, parentTag: "td" }));
      if (i < rows.length - 1 || j < columns.length - 1) contents.push({ tag: "br" });
    }
  }
  return contents;
};

const childrenToText = (children: Array<TelegraphNode>): string =>
  children.map((child) => (typeof child === "string" ? child : childrenToText(child.children || []))).join("");

const nodesToHtml = (nodes: Array<TelegraphNode>): string => {
  return nodes
    .map((node) => {
      if (typeof node === "string") return node;
      const attrs = node.attrs ? " " + Object.entries(node.attrs).map(([k, v]) => `${k}="${v}"`).join(" ") : "";
      const children = node.children ? nodesToHtml(node.children) : "";
      if (node.tag === "br" || node.tag === "hr" || node.tag === "img") {
        return `<${node.tag}${attrs}>`;
      }
      return `<${node.tag}${attrs}>${children}</${node.tag}>`;
    })
    .join("");
};
